---
title: tcp三次握手
date: 2018-11-30 14:01:40
tags: [tcp,三次握手]
---

### 一、TCP报文格式

  TCP报文格式图：

![](tcp三次握手\1.png)

上图中有几个字段需要重点介绍下：

1. 序号：`Seq序号`，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
2. 确认序号：`Ack序号`，占32位，只有`ACK标志位`为1时，确认序号字段才有效，`Ack=Seq+1`。
3. 标志位：共6个，即`URG、ACK、PSH、RST、SYN、FIN`等，具体含义如下：
   - `URG`：紧急指针（urgent pointer）有效。
   - `ACK`：确认序号有效。
   - `PSH`：接收方应该尽快将这个报文交给应用层。
   - `RST`：重置连接。
   - `SYN`：发起一个新连接。
   - `FIN`：释放一个连接。 

注：

- 不要将`确认序号Ack`与`标志位中的ACK`搞混了。
- `确认方Ack=发起方Req+1`，**两端配对**。 

<!--more-->

<br/>

### 二、三次握手

![](tcp三次握手\3.png)

![](tcp三次握手\2.png)

（1）第一次握手：**Client将标志位SYN置为1**，随机产生一个值seq=J，并将该数据包发送给Server，**Client进入SYN_SENT状态**，等待Server确认。

 

  （2）第二次握手：**Server收到数据包后由标志位SYN=1知道Client请求建立连接**，Server将标志位SYN和ACK都置为1，ack (number )=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，**Server进入SYN_RCVD状态**。

 

  （3）第三次握手：**Client收到确认后，检查ack是否为J+1，ACK是否为1**，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，**如果正确则连接建立成功，Client和Server进入ESTABLISHED状态**，完成三次握手，随后Client与Server之间可以开始传输数据了。



#### 为什么TCP客户端最后还要发送一次确认呢？

```markdown
一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
```

<br/>