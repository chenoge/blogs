---
title: JS-正则表达式
date: 2017-07-14 20:46:10
tags: [javaScript,正则表达式,RegExp]
---

#### 语法

- `\d`可以匹配一个**数字**，等价于`[0-9] `
- `\w`可以匹配一个**单字字符** （字母、数字或者下划线） ，等价于`[A-Za-z0-9_]` 
- `\W`匹配一个**非单字字符**，等价于`[^A-Za-z0-9_]`
- `.`可以匹配一个**任意字符** ，**换行符**除外
- `\s`匹配一个空白字符，包括**空格**、**制表符**、**换页符**和**换行符**
- `\S`匹配一个非空白字符
- `*`表示**任意个**字符，等价于 `{0,} `
- `+`表示**至少一个**字符，等价于 `{1,}` 
- `?`表示**0个或1个**字符，等价于 `{0,1}` 
- `{n}`表示**n个**字符
- `{n,m}`表示**`n-m`个**字符 
- `\`**转义** 
- `(x)`普通分组，匹配 `'x' `并且**记住匹配项**
- `(?<组名>RegExp)`具名组，使用`$<组名>`引用具名组
- `[xyz]`一个**字符集合**
- `[^xyz]`一个**反向字符集**
- `A|B`可以匹配A**或**B 
- `^`表示**行的开头**或**非的意思** 
- `$`表示行的**结束** 

<!--more-->

<br/>



#### 分组（或捕获组）

**正则表达式**通过使用**括号**将**表达式**分为不同的分组，识别的方法是通过**从左至右搜寻左半括号**，遇到第一个左半括号时，则**该左半括号与对应的右半括号所包含的内容即为第一分组**，以此类推 。

例如，在表达式`((A)(B(C)))`，有四个这样的组：`((A)(B(C)))、(A)、(B(C))、(C)`

<br/>



#### 具名组

- **字符串替换**时，使用`$<组名>`引用具名组

  ```javascript
  let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;
  
  '2015-01-02'.replace(re, '$<day>/$<month>/$<year>');
  ```

- 在**正则表达式内部引用**某个“具名组匹配”，可以使用`\k<组名>`，或者**数字引用**（`\1`）

  ```javascript
  const RE_TWICE = /^(?<word>[a-z]+)!\k<word>!\1$/;
  
  RE_TWICE.test('abc!abc!abc') // true
  
  RE_TWICE.test('abc!abc!ab') // false
  ```

<br/>



#### 位置类元数据

- `(exp)` ：**目标字符串**需要匹配`exp`，并将该分组匹配的**子文本**保存到**自动命名的组**里；



- `(?<name>exp)`：**目标字符串**需要匹配`exp`，并将该分组匹配的**子文本**保存到名称为`name`的组里，也可以写成`(?'name'exp)`；



- `(?:exp)` ：**目标字符串**需要匹配`exp`，该**括号所包括的内容不会被作为一个分组对待**，该表达式与`（exp）`在效果上其实应该是没有区别的，区别只是**是否算作一个分组及是否保存匹配的子文本**。



- `(?=exp)` ：定义目标字符串**结束位置**要求，即**紧随目标字符串后面出现的字符串**需要匹配上`exp`表达式，该字符串不会被计入目标字符串，**表达中出现的括号也不会被视作一个分组**；



- `(?<=exp)`：定义目标字符串**起始位置**要求，即紧邻目标字符串前面出现的字符串需要匹配上`exp`表达式，该字符串不会被计入目标字符串，**表达中出现的括号也不会被视作一个分组**；



- `(?!exp)`：定义目标字符串**结束位置**要求，即紧随目标字符串后面出现的字符串**不能匹配**上`exp`表达式，该字符串不会被计入目标字符串，表达中出现的括号也不会被视作一个分组；效果上与`(?=exp)` 表示的情况刚好相反；



- `(?<!exp)`：定义目标字符串**起始位置**要求，即紧邻目标字符串前面出现的字符串**不能匹配**上`exp`表达式，该字符串不会被计入目标字符串，**表达中出现的括号也不会被视作一个分组**；效果上与`(?<=exp)`表示的情况刚好相反；

```js
str.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,'); // 千分位
```

<br/>



#### 贪婪匹配

贪婪匹配指的是：匹配的子串是最长的，如果符合条件，就一直匹配，返回最长的匹配子串。

非贪婪匹配：如果匹配成功，就返回子串，而不继续向下匹配了，用法就是在**量词**后面加上一个`?`。

```javascript
var str = "aaabbb";
var reg = /a+/g;
console.log(str.match(reg));    // ["aaa"]

// 改为非贪婪匹配，用?，能匹配一次绝对不匹配多次
var reg = /a+?/g;
console.log(str.match(reg));    // ["a","a","a"]
```
